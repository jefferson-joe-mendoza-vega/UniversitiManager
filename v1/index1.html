<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lista de Tareas</title>
    <!-- Agregar manifest para PWA -->
    <link rel="manifest" href="manifest.json">
    <!-- Estilos CSS -->
    <style>
        /* Estilos generales con tema oscuro y colores más suaves */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a; /* Color de fondo más suave */
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            position: relative;
        }

        h1 {
            text-align: center;
            color: #f0f0f0; /* Color de texto más suave */
            margin-top: 20px;
            font-size: 2.5rem;
            letter-spacing: 1px;
        }

        .task-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 30px 20px;
            background-color: #2a2a2a; /* Fondo de contenedor más claro */
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            position: relative; /* Para posicionar el spinner */
        }

        /* Barra de Búsqueda */
        .search-bar {
            width: 100%;
            margin-bottom: 20px;
            position: sticky;
            top: 0;
            background-color: #2a2a2a;
            padding: 10px 0;
            z-index: 100;
            border-bottom: 1px solid #444444;
        }

        .search-bar input {
            width: 100%;
            padding: 10px 15px;
            font-size: 1rem;
            border: 1px solid #555555; /* Borde más suave */
            border-radius: 5px;
            background-color: #4a4a4a; /* Fondo de input más claro */
            color: #ffffff;
            transition: border 0.3s ease;
        }

        .search-bar input:focus {
            border: 1px solid #80cbc4; /* Color de enfoque más suave */
            outline: none;
        }

        /* Botón para abrir el modal */
        .open-modal-btn, .sync-btn {
            display: block;
            width: 220px;
            margin: 20px auto;
            padding: 12px;
            background: linear-gradient(135deg, #7e57c2, #9575cd); /* Gradiente suave */
            color: #ffffff; /* Texto blanco para mejor contraste */
            text-align: center;
            font-size: 1.1rem;
            border: none;
            border-radius: 30px; /* Bordes más redondeados */
            cursor: pointer;
            transition: background 0.5s ease, transform 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .sync-btn {
            background: linear-gradient(135deg, #26a69a, #80cbc4);
            margin-top: 5px;
        }

        .sync-btn.syncing {
            opacity: 0.7;
            cursor: wait;
        }

        .sync-btn-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .sync-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 5px;
        }

        .sync-dot.online {
            background-color: #4caf50;
        }

        .sync-dot.offline {
            background-color: #f44336;
        }

        .open-modal-btn::after, .sync-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: translateY(-50%) scale(0);
            transition: transform 0.5s ease;
        }

        .open-modal-btn:hover::after, .sync-btn:hover::after {
            transform: translateY(-50%) scale(1);
        }

        .open-modal-btn:hover {
            background: linear-gradient(135deg, #6a5dc2, #8468d1);
            transform: translateY(-3px);
        }

        .sync-btn:hover {
            background: linear-gradient(135deg, #1c8d80, #66aaa6);
            transform: translateY(-3px);
        }

        /* Estilos para el modal de agregar/editar tarea */
        .modal, .detail-modal {
            display: none; 
            position: fixed; 
            z-index: 150; 
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); 
            backdrop-filter: blur(5px);
        }

        .modal-content, .detail-modal-content {
            background-color: #333333; /* Fondo del modal más suave */
            margin: 5% auto;
            padding: 25px 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            position: relative;
            color: #e0e0e0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-content input, .modal-content textarea {
            padding: 12px;
            margin-top: 8px;
            font-size: 1rem;
            border: 1px solid #555555; /* Borde más suave */
            border-radius: 5px;
            background-color: #4a4a4a; /* Fondo de input más claro */
            color: #ffffff;
            width: 100%;
            box-sizing: border-box;
            transition: border 0.3s ease;
        }

        .modal-content input:focus, .modal-content textarea:focus {
            border: 1px solid #80cbc4; /* Color de enfoque más suave */
            outline: none;
        }

        .modal-content button, .detail-modal-content button {
            padding: 12px;
            margin-top: 20px;
            font-size: 1rem;
            background: linear-gradient(135deg, #80cbc4, #4db6ac); /* Gradiente suave */
            color: #000000;
            border: none;
            border-radius: 30px; /* Bordes más redondeados */
            cursor: pointer;
            transition: background 0.5s ease, transform 0.3s ease;
            width: 100%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .modal-content button:hover, .detail-modal-content button:hover {
            background: linear-gradient(135deg, #66aaa6, #26a69a);
            transform: translateY(-3px);
        }

        /* Botón de cerrar modal */
        .close-modal-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background-color: transparent;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #e0e0e0;
            transition: color 0.3s ease;
        }

        .close-modal-btn:hover {
            color: #ffffff;
        }

        /* Estilos para la lista de tareas */
        ul {
            margin-top: 40px;
            padding: 0;
            list-style-type: none;
        }

        li {
            background-color: #2a2a2a; /* Fondo de tarea más claro */
            padding: 20px 25px;
            margin-bottom: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        li:hover {
            background-color: #383838;
            transform: translateY(-2px);
        }

        .task-info {
            flex-grow: 1;
            margin-right: 20px;
        }

        .task-info strong {
            font-size: 1.2rem;
            display: block;
            margin-bottom: 5px;
            color: #ffffff;
        }

        .task-info span {
            font-size: 0.95rem;
            color: #bdbdbd;
        }

        .task-actions {
            display: flex;
            gap: 10px;
            margin-left: auto; /* Asegura que las acciones estén al lado derecho */
        }

        .task-actions button {
            padding: 8px 12px;
            font-size: 0.9rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            opacity: 0.9;
        }

        .task-actions button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .edit-btn {
            background-color: #80cbc4; /* Color menos intenso */
            color: #000000;
        }

        .edit-btn:hover {
            background-color: #66aaa6;
            transform: translateY(-1px);
        }

        .delete-btn {
            background-color: #e57373; /* Color menos intenso */
            color: #000000;
        }

        .delete-btn:hover {
            background-color: #ef5350;
            transform: translateY(-1px);
        }

        /* Estilos para el modal de detalles */
        .detail-modal-content img {
            width: 100%;
            max-height: 300px;
            object-fit: cover;
            border-radius: 10px;
            margin-top: 15px;
            transition: transform 0.3s ease;
        }

        .detail-modal-content img:hover {
            transform: scale(1.02);
        }

        /* Estilos para tareas urgentes */
        .urgent {
            background-color: #ff8a80; /* Fondo rojo claro */
            color: #ffffff;
            animation: pulse 2s infinite;
        }

        .urgent .task-actions button {
            color: #ffffff;
        }

        /* Estilos para tareas vencidas */
        .expired {
            background-color: #d32f2f; /* Fondo rojo intenso para mejor contraste */
            color: #ffffff;
            animation: fadeOutIn 1.5s infinite;
        }

        .expired .task-actions button {
            color: #ffffff;
        }

        /* Ajuste de colores de texto en tareas urgentes y vencidas */
        .urgent .task-info strong,
        .urgent .task-info span,
        .expired .task-info strong,
        .expired .task-info span {
            color: #ffffff; /* Texto blanco para mejor contraste */
        }

        /* Animación para tareas urgentes */
        @keyframes pulse {
            0% { box-shadow: 0 0 10px #ff5252; }
            50% { box-shadow: 0 0 20px #ff5252; }
            100% { box-shadow: 0 0 10px #ff5252; }
        }

        /* Animación para tareas vencidas */
        @keyframes fadeOutIn {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .task-container {
                padding: 20px 15px;
            }

            .modal-content, .detail-modal-content {
                padding: 20px 25px;
            }

            .task-info strong {
                font-size: 1rem;
            }

            .task-info span {
                font-size: 0.85rem;
            }

            .open-modal-btn, .sync-btn {
                width: 180px;
                padding: 10px;
                font-size: 1rem;
            }

            li {
                flex-direction: column;
                align-items: flex-start;
            }

            .task-actions {
                margin-top: 10px;
            }

            .search-bar {
                padding: 8px 0;
            }

            .search-bar input {
                padding: 8px 12px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }

            .open-modal-btn, .sync-btn {
                width: 160px;
                padding: 8px;
                font-size: 0.95rem;
            }

            .task-info strong {
                font-size: 1rem;
            }

            .task-info span {
                font-size: 0.8rem;
            }

            .task-actions button {
                padding: 6px 10px;
                font-size: 0.8rem;
            }

            .search-bar input {
                font-size: 0.85rem;
                padding: 6px 10px;
            }
        }

        /* Mensajes de notificación */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #333333;
            color: #ffffff;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.3s ease;
            z-index: 200;
            font-size: 1rem;
        }

        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        .notification.success {
            background-color: #4caf50;
        }

        .notification.error {
            background-color: #f44336;
        }

        /* Vista Previa de Imagen en el Modal */
        .image-preview {
            margin-top: 10px;
            max-width: 100%;
            max-height: 200px;
            display: none;
            border-radius: 5px;
        }

        /* Estilos para listas en la descripción */
        .description ul {
            list-style-type: disc;
            margin-left: 20px;
            padding-left: 0;
        }

        .description li {
            margin-bottom: 5px;
        }

        /* Spinner de Carga */
        .spinner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 200; /* Superior a otros elementos */
            display: none; /* Oculto por defecto */
        }

        .spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #4db6ac; /* Azul */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Deshabilitar el cursor durante la carga */
        body.loading {
            overflow: hidden;
            cursor: wait;
        }

        /* Agregar estilos para el indicador offline */
        .offline-indicator {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #ff8a80;
            color: white;
            text-align: center;
            padding: 8px;
            z-index: 1000;
            font-weight: bold;
        }

        body.offline .offline-indicator {
            display: block;
        }

        /* Estilo para operaciones pendientes */
        .pending-badge {
            display: inline-block;
            background-color: #ffc107;
            color: black;
            border-radius: 50%;
            min-width: 18px;
            height: 18px;
            text-align: center;
            font-size: 12px;
            margin-left: 8px;
            line-height: 18px;
        }

        /* Estilo para elementos sin tareas en modo offline */
        .no-tasks {
            text-align: center;
            padding: 20px;
            background-color: #333333;
            border-radius: 8px;
            font-style: italic;
            color: #bdbdbd;
        }
    </style>
</head>
<body>
    <!-- Indicador de modo offline -->
    <div class="offline-indicator">
        MODO SIN CONEXIÓN - Los cambios se guardarán localmente
    </div>

    <div class="task-container">
        <h1>Lista de Tareas <span id="pendingCount" class="pending-badge" style="display: none;"></span></h1>

        <!-- Barra de Búsqueda -->
        <div class="search-bar">
            <input type="text" id="searchInput" placeholder="Buscar tareas...">
        </div>

        <!-- Botones para agregar y sincronizar -->
        <div class="button-container">
            <button class="open-modal-btn" id="openModalBtn">Agregar Tarea</button>
            
            <div class="sync-btn-container">
                <button class="sync-btn" id="syncBtn">
                    <span id="syncBtnText">Sincronizar Cambios</span>
                    <span class="sync-dot" id="statusDot"></span>
                </button>
            </div>
        </div>

        <!-- Spinner de Carga -->
        <div class="spinner-overlay" id="spinnerOverlay">
            <div class="spinner"></div>
        </div>

        <!-- Modal para agregar/editar tarea -->
        <div id="taskModal" class="modal" role="dialog" aria-labelledby="modalTitle" aria-modal="true">
            <div class="modal-content">
                <button class="close-modal-btn" id="closeModalBtn" aria-label="Cerrar Modal">&times;</button>
                <h2 id="modalTitle">Agregar Nueva Tarea</h2>
                <form id="taskForm">
                    <label for="taskName">Nombre de la tarea:</label>
                    <input type="text" id="taskName" required>

                    <label for="dueDate">Fecha de vencimiento:</label>
                    <input type="date" id="dueDate" required>

                    <label for="description">Descripción:</label>
                    <textarea id="description" placeholder="Opcional"></textarea>

                    <label for="taskImage">Imagen de la tarea:</label>
                    <input type="file" id="taskImage" accept="image/*">
                    <img id="imagePreview" class="image-preview" src="" alt="Vista Previa de la Imagen">

                    <button type="submit" id="submitBtn">Agregar Tarea</button>
                </form>
            </div>
        </div>

        <!-- Modal para mostrar detalles de la tarea -->
        <div id="detailModal" class="detail-modal" role="dialog" aria-labelledby="detailTaskName" aria-modal="true">
            <div class="detail-modal-content">
                <button class="close-modal-btn" id="closeDetailModalBtn" aria-label="Cerrar Modal">&times;</button>
                <h2 id="detailTaskName"></h2>
                <p><strong>Fecha de vencimiento:</strong> <span id="detailDueDate"></span></p>
                <div id="detailDescriptionContainer">
                    <p><strong>Descripción:</strong></p>
                    <div id="detailDescription" class="description"></div>
                </div>
                <img id="detailImage" src="" alt="Imagen tarea" style="display: none;">
                <button id="closeDetailButton">Cerrar</button>
            </div>
        </div>

        <ul id="tasksList"></ul>
    </div>

    <!-- Notificación -->
    <div id="notification" class="notification" role="alert" aria-live="assertive"></div>

    <!-- Importar Firebase como módulos -->
    <script type="module">
        // Importar funciones necesarias de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js";
        import { 
            getFirestore, 
            collection, 
            getDocs, 
            addDoc, 
            updateDoc, 
            deleteDoc, 
            doc, 
            getDoc,
            enableIndexedDbPersistence,
            setDoc,
            onSnapshot
        } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore.js";

        // Configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDJphtweEVrvaVn4i-UwKuMHGCtX_LPl_g",
            authDomain: "tareaspendientes-1cadf.firebaseapp.com",
            projectId: "tareaspendientes-1cadf",
            storageBucket: "tareaspendientes-1cadf.firebasestorage.app",
            messagingSenderId: "580768863245",
            appId: "1:580768863245:web:28aa8abdc6f4281c7a7144",
            measurementId: "G-NH654YBBF5"
        };

        // Inicializa Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        // Obtener elementos del DOM
        const taskForm = document.getElementById('taskForm');
        const taskNameInput = document.getElementById('taskName');
        const dueDateInput = document.getElementById('dueDate');
        const descriptionInput = document.getElementById('description');
        const taskImageInput = document.getElementById('taskImage');
        const imagePreview = document.getElementById('imagePreview');
        const tasksList = document.getElementById('tasksList');
        const openModalBtn = document.getElementById('openModalBtn');
        const syncBtn = document.getElementById('syncBtn');
        const syncBtnText = document.getElementById('syncBtnText');
        const statusDot = document.getElementById('statusDot');
        const taskModal = document.getElementById('taskModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalTitle = document.getElementById('modalTitle');
        const submitBtn = document.getElementById('submitBtn');
        const detailModal = document.getElementById('detailModal');
        const closeDetailModalBtn = document.getElementById('closeDetailModalBtn');
        const closeDetailButton = document.getElementById('closeDetailButton');
        const detailTaskName = document.getElementById('detailTaskName');
        const detailDueDate = document.getElementById('detailDueDate');
        const detailDescription = document.getElementById('detailDescription');
        const detailImage = document.getElementById('detailImage');
        const detailDescriptionContainer = document.getElementById('detailDescriptionContainer');
        const notification = document.getElementById('notification');
        const spinnerOverlay = document.getElementById('spinnerOverlay');
        const searchInput = document.getElementById('searchInput');
        const pendingCountBadge = document.getElementById('pendingCount');

        let editMode = false;
        let currentEditTaskId = null;
        let allTasks = []; // Almacena todas las tareas para el buscador
        let isOnline = navigator.onLine;
        let isCurrentlySyncing = false;
        
        // Objetos para gestionar tareas pendientes
        let pendingTasks = {
            add: [],
            update: [],
            delete: []
        };

        // API Key de ImgBB
        const imgbbAPIKey = '6919281ff26b04eeaa4fc95ae5745889';

        /**
         * Habilitar persistencia offline de Firestore
         */
        async function enableOfflinePersistence() {
            try {
                await enableIndexedDbPersistence(db);
                console.log("Persistencia offline habilitada");
            } catch (err) {
                if (err.code === 'failed-precondition') {
                    console.warn("La persistencia falló debido a múltiples pestañas abiertas");
                    showNotification("La persistencia offline puede no funcionar correctamente debido a múltiples pestañas abiertas", "error");
                } else if (err.code === 'unimplemented') {
                    console.warn("El navegador no soporta persistencia offline");
                    showNotification("Tu navegador no soporta el funcionamiento sin conexión", "error");
                }
            }
        }

        // Llamar a la función para habilitar persistencia
        enableOfflinePersistence();

        /**
         * Obtiene la fecha actual en la zona horaria de Perú (UTC-5).
         * @returns {Date} - Fecha actual en Perú sin tiempo.
         */
        function getCurrentPeruDate() {
            const now = new Date();
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            // Perú está en UTC-5
            const peruTime = new Date(utc - (5 * 60 * 60 * 1000));
            return new Date(peruTime.getFullYear(), peruTime.getMonth(), peruTime.getDate());
        }

        /**
         * Función para mostrar notificaciones
         * @param {string} message - Mensaje de la notificación
         * @param {string} type - Tipo de notificación ('success' o 'error')
         */
        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        /**
         * Función para mostrar el spinner de carga
         */
        function showSpinner() {
            spinnerOverlay.style.display = 'flex';
            document.body.classList.add('loading');
            // Deshabilitar botones y inputs
            disableInteractions(true);
        }

        /**
         * Función para ocultar el spinner de carga
         */
        function hideSpinner() {
            spinnerOverlay.style.display = 'none';
            document.body.classList.remove('loading');
            // Habilitar botones y inputs
            disableInteractions(false);
        }

        /**
         * Función para deshabilitar interacciones durante la carga
         * @param {boolean} disable - Estado para deshabilitar o habilitar
         */
        function disableInteractions(disable) {
            const buttons = document.querySelectorAll('button:not(#syncBtn)');
            const inputs = document.querySelectorAll('input, textarea');
            buttons.forEach(btn => {
                btn.disabled = disable;
            });
            inputs.forEach(input => {
                input.disabled = disable;
            });
        }

        /**
         * Actualiza el contador de operaciones pendientes
         */
        function updatePendingCount() {
            // Contar todas las operaciones pendientes
            const pendingCount = pendingTasks.add.length + 
                                 pendingTasks.update.length + 
                                 pendingTasks.delete.length;
            
            if (pendingCount > 0) {
                pendingCountBadge.textContent = pendingCount;
                pendingCountBadge.style.display = 'inline-block';
            } else {
                pendingCountBadge.style.display = 'none';
            }
            
            // Actualizar el texto del botón de sincronización
            if (pendingCount > 0) {
                syncBtnText.textContent = `Sincronizar (${pendingCount})`;
                syncBtn.disabled = !isOnline;
            } else {
                syncBtnText.textContent = "Sincronizar";
                syncBtn.disabled = !isOnline || pendingCount === 0;
            }
        }

        /**
         * Función para actualizar la UI según el estado de conexión
         */
        function updateConnectionUI() {
            if (isOnline) {
                document.body.classList.remove('offline');
                statusDot.classList.remove('offline');
                statusDot.classList.add('online');
                statusDot.title = 'Conectado';
            } else {
                document.body.classList.add('offline');
                statusDot.classList.remove('online');
                statusDot.classList.add('offline');
                statusDot.title = 'Sin conexión';
            }
            
            // Actualizar estado del botón de sincronización
            syncBtn.disabled = !isOnline || (pendingTasks.add.length + pendingTasks.update.length + pendingTasks.delete.length === 0);
            
            updatePendingCount();
        }

        /**
         * Función para cargar tareas pendientes desde localStorage
         */
        function loadPendingTasksFromStorage() {
            try {
                const storedAdd = localStorage.getItem('pending_add_tasks');
                const storedUpdate = localStorage.getItem('pending_update_tasks');
                const storedDelete = localStorage.getItem('pending_delete_tasks');
                
                pendingTasks.add = storedAdd ? JSON.parse(storedAdd) : [];
                pendingTasks.update = storedUpdate ? JSON.parse(storedUpdate) : [];
                pendingTasks.delete = storedDelete ? JSON.parse(storedDelete) : [];
                
                updatePendingCount();
            } catch (error) {
                console.error('Error al cargar tareas pendientes:', error);
                pendingTasks = { add: [], update: [], delete: [] };
            }
        }

        /**
         * Función para guardar tareas pendientes en localStorage
         */
        function savePendingTasksToStorage() {
            try {
                localStorage.setItem('pending_add_tasks', JSON.stringify(pendingTasks.add));
                localStorage.setItem('pending_update_tasks', JSON.stringify(pendingTasks.update));
                localStorage.setItem('pending_delete_tasks', JSON.stringify(pendingTasks.delete));
                updatePendingCount();
            } catch (error) {
                console.error('Error al guardar tareas pendientes:', error);
            }
        }

        /**
         * Función para sincronizar todas las tareas pendientes con Firebase
         */
        async function syncTasks() {
            if (!isOnline || isCurrentlySyncing) return;
            
            isCurrentlySyncing = true;
            syncBtn.classList.add('syncing');
            syncBtnText.textContent = "Sincronizando...";
            showSpinner();
            
            try {
                // 1. Procesar eliminaciones
                if (pendingTasks.delete.length > 0) {
                    for (let i = 0; i < pendingTasks.delete.length; i++) {
                        const taskId = pendingTasks.delete[i];
                        try {
                            await deleteDoc(doc(db, 'tareas', taskId));
                            console.log(`Tarea eliminada con ID: ${taskId}`);
                        } catch (error) {
                            console.error(`Error al eliminar tarea ${taskId}:`, error);
                        }
                    }
                    pendingTasks.delete = [];
                }
                
                // 2. Procesar adiciones
                if (pendingTasks.add.length > 0) {
                    for (let i = 0; i < pendingTasks.add.length; i++) {
                        const taskData = pendingTasks.add[i];
                        try {
                            // Eliminar marcador de pendiente
                            const { pendingSave, ...cleanData } = taskData;
                            const docRef = await addDoc(collection(db, 'tareas'), cleanData);
                            console.log(`Tarea agregada con ID: ${docRef.id}`);
                            
                            // Actualizar la referencia en allTasks si existe
                            const index = allTasks.findIndex(t => t.nombre === taskData.nombre && 
                                                            t.fecha === taskData.fecha &&
                                                            t.pendingSave === true);
                            if (index !== -1) {
                                allTasks[index].id = docRef.id;
                                allTasks[index].pendingSave = false;
                            }
                        } catch (error) {
                            console.error('Error al agregar tarea:', error);
                        }
                    }
                    pendingTasks.add = [];
                }
                
                // 3. Procesar actualizaciones
                if (pendingTasks.update.length > 0) {
                    for (let i = 0; i < pendingTasks.update.length; i++) {
                        const task = pendingTasks.update[i];
                        try {
                            const { id, pendingSave, ...updateData } = task;
                            await updateDoc(doc(db, 'tareas', id), updateData);
                            console.log(`Tarea actualizada con ID: ${id}`);
                            
                            // Actualizar en allTasks
                            const index = allTasks.findIndex(t => t.id === id);
                            if (index !== -1) {
                                allTasks[index].pendingSave = false;
                            }
                        } catch (error) {
                            console.error(`Error al actualizar tarea ${task.id}:`, error);
                        }
                    }
                    pendingTasks.update = [];
                }
                
                // Guardar el estado de las tareas pendientes
                savePendingTasksToStorage();
                
                // Recargar las tareas para tener los datos actualizados
                await loadTasks();
                
                showNotification('Sincronización completada con éxito', 'success');
            } catch (error) {
                console.error('Error durante la sincronización:', error);
                showNotification('Error durante la sincronización: ' + error.message, 'error');
            } finally {
                isCurrentlySyncing = false;
                syncBtn.classList.remove('syncing');
                updatePendingCount();
                hideSpinner();
            }
        }

        /**
         * Función para abrir el modal de agregar/editar tarea
         * @param {boolean} isEdit - Indica si es modo edición
         * @param {object} task - Datos de la tarea a editar
         */
        function openTaskModal(isEdit = false, task = {}) {
            taskModal.style.display = 'block';
            if (isEdit) {
                modalTitle.textContent = 'Editar Tarea';
                submitBtn.textContent = 'Actualizar Tarea';
                taskNameInput.value = task.nombre;
                dueDateInput.value = task.fecha;
                descriptionInput.value = task.descripcion || '';
                // Mostrar vista previa de la imagen existente si está disponible
                if (task.urlImagen) {
                    imagePreview.src = task.urlImagen;
                    imagePreview.style.display = 'block';
                } else {
                    imagePreview.style.display = 'none';
                }
                taskImageInput.value = ''; // Resetear el input de archivo
                editMode = true;
                currentEditTaskId = task.id;
            } else {
                modalTitle.textContent = 'Agregar Nueva Tarea';
                submitBtn.textContent = 'Agregar Tarea';
                taskForm.reset();
                imagePreview.style.display = 'none';
                editMode = false;
                currentEditTaskId = null;
            }
        }

        /**
         * Función para cerrar el modal de agregar/editar tarea
         */
        function closeTaskModal() {
            taskModal.style.display = 'none';
            taskForm.reset();
            imagePreview.style.display = 'none';
            editMode = false;
            currentEditTaskId = null;
        }

        /**
         * Función para abrir el modal de detalles de la tarea
         * @param {string} taskId - ID de la tarea
         */
        async function openDetailModal(taskId) {
            showSpinner();
            try {
                // Buscar primero en la caché local
                const cachedTask = allTasks.find(t => t.id === taskId);
                
                if (cachedTask) {
                    displayTaskDetails(cachedTask);
                } else if (isOnline) {
                    // Si no está en caché y estamos online, buscar en Firestore
                    const taskRef = doc(db, 'tareas', taskId);
                    const taskSnap = await getDoc(taskRef);
                    
                    if (taskSnap.exists()) {
                        const task = taskSnap.data();
                        displayTaskDetails({...task, id: taskId});
                    } else {
                        showNotification('La tarea no existe!', 'error');
                    }
                } else {
                    showNotification('No se puede acceder a los detalles sin conexión', 'error');
                }
            } catch (error) {
                console.error('Error al abrir detalles de la tarea:', error);
                showNotification('Error al abrir detalles de la tarea.', 'error');
            } finally {
                hideSpinner();
            }
        }

        /**
         * Muestra los detalles de una tarea en el modal
         * @param {Object} task - La tarea a mostrar
         */
        function displayTaskDetails(task) {
            detailTaskName.textContent = task.nombre;
            detailDueDate.textContent = task.fecha;
            
            if (task.descripcion) {
                detailDescription.innerHTML = parseDescription(task.descripcion);
                detailDescriptionContainer.style.display = 'block';
            } else {
                detailDescriptionContainer.style.display = 'none';
            }

            if (task.urlImagen) {
                detailImage.src = task.urlImagen;
                detailImage.alt = `Imagen de la tarea: ${task.nombre}`;
                detailImage.style.display = 'block';
            } else {
                detailImage.style.display = 'none';
            }

            detailModal.style.display = 'block';
        }

        /**
         * Función para cerrar el modal de detalles
         */
        function closeDetailModalFunc() {
            detailModal.style.display = 'none';
        }

        /**
         * Función para calcular los días restantes
         * @param {string} dueDate - Fecha de vencimiento en formato 'YYYY-MM-DD'
         * @returns {number} - Días restantes
         */
        function getDaysLeft(dueDate) {
            const currentPeruDate = getCurrentPeruDate();
            const [year, month, day] = dueDate.split('-').map(Number);
            const due = new Date(year, month -1, day);
            // Calcular diferencia en milisegundos
            const timeDiff = due - currentPeruDate;
            const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
            return daysDiff;
        }

        /**
         * Función para obtener el mensaje de días restantes
         * @param {number} daysLeft - Días restantes
         * @returns {string} - Mensaje correspondiente
         */
        function getDueMessage(daysLeft) {
            if (daysLeft === 1) {
                return 'Vence mañana';
            } else if (daysLeft > 1 && daysLeft <= 5) {
                return `Vence en ${daysLeft} días`;
            } else if (daysLeft <= 0) {
                return 'Ya venció';
            } else {
                return `Vence en más de 5 días`;
            }
        }

        /**
         * Función para parsear la descripción y convertir guiones/puntos en listas
         * @param {string} text - Texto de la descripción
         * @returns {string} - HTML formateado
         */
        function parseDescription(text) {
            // Reemplazar líneas que comienzan con '-' o '.' seguidas de espacio por <li>
            const lines = text.split('\n');
            let html = '';
            let inList = false;
            let listType = '';

            lines.forEach(line => {
                if (/^-\s+/.test(line)) {
                    if (!inList) {
                        inList = true;
                        listType = 'ul';
                        html += '<ul>';
                    }
                    const item = line.replace(/^-+\s+/, '');
                    html += `<li>${item}</li>`;
                } else if (/^\.\s+/.test(line)) {
                    if (!inList) {
                        inList = true;
                        listType = 'ol';
                        html += '<ol>';
                    }
                    const item = line.replace(/^\.\s+/, '');
                    html += `<li>${item}</li>`;
                } else {
                    if (inList) {
                        if (listType === 'ul') {
                            html += '</ul>';
                        } else {
                            html += '</ol>';
                        }
                        inList = false;
                        listType = '';
                    }
                    if (line.trim() !== '') {
                        html += `<p>${line}</p>`;
                    }
                }
            });

            if (inList) {
                if (listType === 'ul') {
                    html += '</ul>';
                } else {
                    html += '</ol>';
                }
            }

            return html;
        }

        /**
         * Función para subir la imagen a ImgBB y obtener la URL
         * @param {File} file - Archivo de imagen
         * @returns {Promise<string>} - URL de la imagen subida
         */
        async function uploadImageToImgBB(file) {
            if (!isOnline) {
                throw new Error('No se pueden subir imágenes sin conexión');
            }
            
            const formData = new FormData();
            formData.append('image', file);

            try {
                const response = await fetch(`https://api.imgbb.com/1/upload?key=${imgbbAPIKey}`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data.success) {
                    return data.data.url;
                } else {
                    throw new Error('Error al subir la imagen a ImgBB');
                }
            } catch (error) {
                console.error('Error al subir la imagen:', error);
                throw error;
            }
        }

        /**
         * Mostrar vista previa de la imagen seleccionada
         */
        taskImageInput.addEventListener('change', () => {
            const file = taskImageInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = 'block';
                }
                reader.readAsDataURL(file);
            } else {
                imagePreview.style.display = 'none';
            }
        });

        /**
         * Abrir el modal de agregar tarea
         */
        openModalBtn.addEventListener('click', () => {
            openTaskModal();
        });

        /**
         * Cerrar el modal de agregar/editar tarea
         */
        closeModalBtn.addEventListener('click', () => {
            closeTaskModal();
        });

        /**
         * Botón de sincronización manual
         */
        syncBtn.addEventListener('click', async () => {
            if (!isOnline) {
                showNotification('No hay conexión a internet. Conéctate para sincronizar.', 'error');
                return;
            }
            
            if (isCurrentlySyncing) {
                showNotification('Ya hay una sincronización en curso.', 'error');
                return;
            }
            
            await syncTasks();
        });

        /**
         * Cerrar el modal de detalles
         */
        closeDetailModalBtn.addEventListener('click', () => {
            closeDetailModalFunc();
        });

        closeDetailButton.addEventListener('click', () => {
            closeDetailModalFunc();
        });

        /**
         * Escuchar cambios en la conexión
         */
        window.addEventListener('online', () => {
            isOnline = true;
            updateConnectionUI();
            showNotification('Conexión restablecida. Usa el botón "Sincronizar" para publicar tus cambios.', 'success');
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateConnectionUI();
            showNotification('Modo sin conexión. Los cambios se guardarán localmente.', 'error');
        });

        /**
         * Agregar o editar una tarea (versión con soporte offline)
         */
        taskForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            showSpinner();

            const taskName = taskNameInput.value.trim();
            const dueDate = dueDateInput.value;
            const description = descriptionInput.value.trim();
            const imageFile = taskImageInput.files[0];

            // Validación: solo nombre y fecha son obligatorios
            if (!taskName || !dueDate) {
                showNotification('Por favor, completa los campos obligatorios.', 'error');
                hideSpinner();
                return;
            }

            // Validación básica de fecha
            const currentPeruDate = getCurrentPeruDate();
            const [year, month, day] = dueDate.split('-').map(Number);
            const selectedDate = new Date(year, month -1, day);
            if (selectedDate < currentPeruDate) {
                showNotification('La fecha de vencimiento no puede ser anterior a hoy.', 'error');
                hideSpinner();
                return;
            }

            try {
                let imageUrl = '';

                // Manejar la imagen sólo si estamos online
                if (isOnline && imageFile) {
                    try {
                        imageUrl = await uploadImageToImgBB(imageFile);
                    } catch (error) {
                        console.error('Error al subir imagen:', error);
                        showNotification('Error al subir imagen. La tarea se guardará sin imagen.', 'error');
                    }
                } else if (editMode && !imageFile) {
                    // Si estamos editando y no hay nueva imagen, intentar obtener la URL existente
                    const existingTask = allTasks.find(t => t.id === currentEditTaskId);
                    if (existingTask && existingTask.urlImagen) {
                        imageUrl = existingTask.urlImagen;
                    } else if (isOnline) {
                        try {
                            const taskRef = doc(db, 'tareas', currentEditTaskId);
                            const taskSnap = await getDoc(taskRef);
                            if (taskSnap.exists()) {
                                imageUrl = taskSnap.data().urlImagen || '';
                            }
                        } catch (error) {
                            console.log('No se pudo obtener la imagen existente:', error);
                        }
                    }
                }

                const taskData = {
                    nombre: taskName,
                    fecha: dueDate,
                    descripcion: description || '',
                    urlImagen: imageUrl,
                    lastUpdated: new Date().toISOString()
                };

                if (!editMode) {
                    // Agregar una nueva tarea
                    if (isOnline && !isCurrentlySyncing) {
                        // Si estamos online, agregar directamente a Firestore
                        try {
                            const docRef = await addDoc(collection(db, 'tareas'), taskData);
                            // Añadir a la caché local
                            allTasks.push({...taskData, id: docRef.id, pendingSave: false});
                            showNotification('Tarea agregada correctamente!', 'success');
                        } catch (error) {
                            console.error('Error al agregar tarea en Firebase:', error);
                            
                            // Si falla, agregar a pendientes
                            const pendingTask = {...taskData, pendingSave: true};
                            pendingTasks.add.push(pendingTask);
                            savePendingTasksToStorage();
                            
                            // Añadir a la caché local con un ID temporal
                            const tempId = 'temp_' + Date.now();
                            allTasks.push({...pendingTask, id: tempId});
                            
                            showNotification('No se pudo sincronizar la tarea. Se guardó localmente.', 'error');
                        }
                    } else {
                        // Si estamos offline, guardar para sincronizar después
                        const pendingTask = {...taskData, pendingSave: true};
                        pendingTasks.add.push(pendingTask);
                        savePendingTasksToStorage();
                        
                        // Añadir a la caché local con un ID temporal
                        const tempId = 'temp_' + Date.now();
                        allTasks.push({...pendingTask, id: tempId});
                        
                        showNotification('Tarea guardada localmente. Se sincronizará cuando haya conexión.', 'success');
                    }
                } else {
                    // Actualizar tarea existente
                    if (isOnline && !isCurrentlySyncing) {
                        // Si estamos online, actualizar directamente en Firestore
                        try {
                            const taskRef = doc(db, 'tareas', currentEditTaskId);
                            await updateDoc(taskRef, taskData);
                            
                            // Actualizar en caché local
                            const index = allTasks.findIndex(t => t.id === currentEditTaskId);
                            if (index !== -1) {
                                allTasks[index] = {...taskData, id: currentEditTaskId, pendingSave: false};
                            }
                            
                            showNotification('Tarea actualizada correctamente!', 'success');
                        } catch (error) {
                            console.error('Error al actualizar tarea en Firebase:', error);
                            
                            // Si falla, agregar a pendientes
                            const pendingTask = {...taskData, id: currentEditTaskId, pendingSave: true};
                            pendingTasks.update.push(pendingTask);
                            savePendingTasksToStorage();
                            
                            // Actualizar en caché local
                            const index = allTasks.findIndex(t => t.id === currentEditTaskId);
                            if (index !== -1) {
                                allTasks[index] = {...pendingTask};
                            }
                            
                            showNotification('No se pudo sincronizar la actualización. Se guardó localmente.', 'error');
                        }
                    } else {
                        // Si estamos offline, guardar para sincronizar después
                        const pendingTask = {...taskData, id: currentEditTaskId, pendingSave: true};
                        pendingTasks.update.push(pendingTask);
                        savePendingTasksToStorage();
                        
                        // Actualizar en caché local
                        const index = allTasks.findIndex(t => t.id === currentEditTaskId);
                        if (index !== -1) {
                            allTasks[index] = {...pendingTask};
                        }
                        
                        showNotification('Actualización guardada localmente. Se sincronizará cuando haya conexión.', 'success');
                    }
                }

                taskForm.reset();
                imagePreview.style.display = 'none';
                taskModal.style.display = 'none';
                
                // Ordenar y actualizar la interfaz
                allTasks.sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
                renderTasks(allTasks);
                updatePendingCount();
                updateConnectionUI();
            } catch (error) {
                console.error('Error al agregar/actualizar tarea:', error);
                showNotification(`Error: ${error.message}`, 'error');
            } finally {
                hideSpinner();
            }
        });

        /**
         * Eliminar tarea (versión con soporte offline)
         */
        async function deleteTask(taskId) {
            if (confirm('¿Estás seguro de que deseas eliminar esta tarea?')) {
                showSpinner();
                try {
                    if (isOnline && !isCurrentlySyncing) {
                        // Si estamos online, eliminar directamente de Firestore
                        try {
                            await deleteDoc(doc(db, 'tareas', taskId));
                            showNotification('Tarea eliminada correctamente!', 'success');
                        } catch (error) {
                            console.error('Error al eliminar tarea de Firebase:', error);
                            
                            // Si falla, agregar a pendientes
                            if (!taskId.startsWith('temp_')) { // No agregar IDs temporales
                                pendingTasks.delete.push(taskId);
                                savePendingTasksToStorage();
                            }
                            
                            showNotification('No se pudo sincronizar la eliminación. Se guardó para eliminar cuando haya conexión.', 'error');
                        }
                    } else {
                        // Si estamos offline, guardar para sincronizar después
                        if (!taskId.startsWith('temp_')) { // No agregar IDs temporales
                            pendingTasks.delete.push(taskId);
                            savePendingTasksToStorage();
                        }
                        
                        showNotification('Eliminación guardada localmente. Se sincronizará cuando haya conexión.', 'success');
                    }
                    
                    // Eliminar de nuestra caché local en cualquier caso
                    allTasks = allTasks.filter(t => t.id !== taskId);
                    renderTasks(allTasks);
                    
                    updatePendingCount();
                    updateConnectionUI();
                } catch (error) {
                    console.error('Error eliminando tarea:', error);
                    showNotification('Error al eliminar tarea.', 'error');
                } finally {
                    hideSpinner();
                }
            }
        }

        /**
         * Cargar las tareas (versión modificada para soporte offline)
         */
        async function loadTasks() {
            tasksList.innerHTML = '';
            showSpinner();

            try {
                // Si estamos online, obtenemos datos de Firestore
                if (isOnline) {
                    try {
                        const snapshot = await getDocs(collection(db, 'tareas'));
                        allTasks = [];

                        snapshot.forEach((docSnap) => {
                            const task = docSnap.data();
                            const taskId = docSnap.id;
                            
                            // Comprobar si hay operaciones pendientes para esta tarea
                            const isPendingUpdate = pendingTasks.update.some(t => t.id === taskId);
                            const isPendingDelete = pendingTasks.delete.includes(taskId);
                            
                            // Solo agregar si no está pendiente de eliminar
                            if (!isPendingDelete) {
                                // Si está pendiente de actualizar, usar los datos locales
                                if (isPendingUpdate) {
                                    const pendingTask = pendingTasks.update.find(t => t.id === taskId);
                                    allTasks.push({ ...pendingTask, pendingSave: true });
                                } else {
                                    allTasks.push({ ...task, id: taskId, pendingSave: false });
                                }
                            }
                        });
                        
                        // Agregar tareas pendientes de crear que no estén en Firestore
                        pendingTasks.add.forEach(task => {
                            const tempId = 'temp_' + Date.now();
                            allTasks.push({ ...task, id: tempId, pendingSave: true });
                        });
                    } catch (error) {
                        console.error('Error al obtener tareas de Firebase:', error);
                        showNotification('Error al obtener tareas desde el servidor', 'error');
                    }
                } 
                
                // Si no hay tareas (online u offline), mostrar mensaje
                if (allTasks.length === 0) {
                    tasksList.innerHTML = '<li class="no-tasks">No hay tareas disponibles.</li>';
                } else {
                    // Ordenar las tareas por fecha de vencimiento (ascendente)
                    allTasks.sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
                    renderTasks(allTasks);
                }
                
                updateConnectionUI();
            } catch (error) {
                console.error('Error al cargar las tareas:', error);
                showNotification('Error al cargar las tareas: ' + error.message, 'error');
            } finally {
                hideSpinner();
            }
        }

        /**
         * Renderizar tareas (modificado para mostrar estado de sincronización)
         */
        function renderTasks(tasks) {
            tasksList.innerHTML = '';

            if (tasks.length === 0) {
                tasksList.innerHTML = '<li class="no-tasks">No hay tareas disponibles.</li>';
                return;
            }

            tasks.forEach((task) => {
                const taskId = task.id;
                const daysLeft = getDaysLeft(task.fecha);
                const dueMessage = getDueMessage(daysLeft);

                const taskElement = document.createElement('li');

                // Asignar clase según el estado de la tarea
                if (daysLeft > 0 && daysLeft <= 5) {
                    taskElement.classList.add('urgent');
                } else if (daysLeft <= 0) {
                    taskElement.classList.add('expired');
                }

                // Contenedor de información de la tarea
                const taskInfo = document.createElement('div');
                taskInfo.classList.add('task-info');
                
                // Mostrar indicador de pendiente de sincronización
                let pendingIndicator = '';
                if (task.pendingSave) {
                    pendingIndicator = '<span class="pending-badge" title="Pendiente de sincronizar">⟳</span>';
                }
                
                taskInfo.innerHTML = `
                    <strong>${task.nombre} ${pendingIndicator}</strong>
                    <span>${task.fecha} (${dueMessage})</span>
                `;

                // Contenedor de acciones (Editar y Eliminar)
                const taskActions = document.createElement('div');
                taskActions.classList.add('task-actions');
                taskActions.innerHTML = `
                    <button class="edit-btn">Editar</button>
                    <button class="delete-btn">Eliminar</button>
                `;

                // Añadir eventos a los botones
                const editBtn = taskActions.querySelector('.edit-btn');
                const deleteBtn = taskActions.querySelector('.delete-btn');

                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openTaskModal(true, { ...task, id: taskId });
                });

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteTask(taskId);
                });

                // Añadir evento para abrir el modal de detalles
                taskElement.addEventListener('click', () => {
                    openDetailModal(taskId);
                });

                // Añadir los contenedores al li
                taskElement.appendChild(taskInfo);
                taskElement.appendChild(taskActions);

                tasksList.appendChild(taskElement);
            });
        }

                /**
         * Función para filtrar tareas según el texto de búsqueda
         * @param {string} query - Texto de búsqueda
         */
         function filterTasks(query) {
            const filtered = allTasks.filter(task => 
                task.nombre.toLowerCase().includes(query.toLowerCase()) ||
                task.descripcion.toLowerCase().includes(query.toLowerCase())
            );
            renderTasks(filtered);
        }

        /**
         * Event listener para el buscador
         */
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim();
            filterTasks(query);
        });

        /**
         * Cerrar modales al hacer clic fuera de ellos
         */
        window.addEventListener('click', (e) => {
            if (e.target == taskModal) {
                closeTaskModal();
            }
            if (e.target == detailModal) {
                closeDetailModalFunc();
            }
        });

        /**
         * Registrar el Service Worker para soporte offline
         */
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registrado con éxito:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Error al registrar el Service Worker:', error);
                    });
            });
        }

        /**
         * Inicialización de la aplicación
         */
        window.addEventListener('load', async () => {
            // Cargar tareas pendientes del almacenamiento local
            loadPendingTasksFromStorage();
            
            // Actualizar estado de conexión
            isOnline = navigator.onLine;
            updateConnectionUI();
            
            // Cargar tareas
            await loadTasks();
            
            // Configurar temporizador para verificar sincronización automática
            // (si el usuario lo prefiere)
            setInterval(() => {
                if (isOnline && !isCurrentlySyncing && 
                    (pendingTasks.add.length > 0 || 
                     pendingTasks.update.length > 0 || 
                     pendingTasks.delete.length > 0)) {
                    console.log("Verificando sincronización automática...");
                    // Puedes descomentar esto para sincronización automática
                    // syncTasks();
                }
            }, 60000); // Verificar cada minuto
        });
    </script>
</body>
</html>